{
	// ---------- for lax json
	function flatten(a) {
		if (a instanceof Array) {
			var result = "";
			for (var i=0; i < a.length; i++) {
				result += flatten(a[i]);
			}
			return result;
		} else {
			return "" + a;
		}
	}

	// Special object as null replacement
	var NULL_OBJECT = {};

	function getValue(value) {
		return value === NULL_OBJECT ? null : value;
	}
	// --------------------

}

start
  = p:property WS* { return p }

property "property"
	= WS* alias:alias? WS* name:name args:args? filters:filter* props:props? { return {
		alias:alias || name,
		name:name,
		args:args || [],
		filters:filters || [],
		props: props || []
	} }

alias "propertyalias"
	= alias:ident WS* ":" { return alias }

name "propertyname"
	= name:ident { return name }

ident
	= $([a-zA-Z_][a-zA-Z0-9_]+)

args "args"
	= "(" args:arg* ")" { return args }

arg "arg"
	= json

filter "filter"
	= "." f:(first / take / slice / unique / count / pluck) { return f }

first "first"
	= "first()" {return {
		name: "first",
		args: []
	} }

take "take"
	= "take(" WS* n:int WS* ")" { return {
		name: "take",
		n: n
	} }

slice "slice"
	= "slice(" WS* start:int WS* "," WS* end:int WS* ")" { return {
		name: "slice",
		start: start,
		end: end
	} }

unique "uniq"
	= "unique()" { return {
		name: "unique"
	} }

count "count"
	= "count()" { return {
		name: "count"
	} }

countBy "countBy"
	= "countBy(" WS* p:property WS* ")" { return {
		name: "countBy",
		prop: p
	} }

sort "sort"
	= "sort(" WS* p:property WS* ")" { return {
		name: "sort",
		prop: p
	} }

pluck "pluck"
	= "pluck(" WS* p:property WS* ")" { return {
		name: "pluck",
		prop: p
	} }

props "property_list"
	= WS* "{" WS* props:property* WS* "}" { return props }

int "integer"
	= digit+

// -------------- json parsing for args-----------------
// https://github.com/jceme/RelaxedJsonParser/blob/master/src/PegjsJsonParser.pegjs

json =
	WS* val:value WS*
{
	return (function(undefined) {
		return val === NULL_OBJECT ? undefined : val;
	})();
}


object "object" =
	'{'
	CWS*
	p:(
		sp:pair CWS*
		{
			return sp;
		}
	)*
	'}'
{
	var result = {}, i, len = p.length, b;
	for (i=0; i < len; i++) {
		b = p[i];
		result[b.id] = b.val;
	}
	return result;
}


pair "objectPair" =
	id:( string / key )
	WS*
	':'
	WS*
	val:value
{
	return { id: flatten(id), val: getValue(val) };
}


key "key" = [a-zA-Z0-9_$]+


array "array" =
	'['
	CWS*
	vals:(
		v:value CWS*
		{
			return v;
		}
	)*
	']'
{
	return vals.map(function(val) {
		return getValue(val);
	});
}


value =
	object
	/ array
	/ string
	/ boolean
	/ null
	/ number


boolean "boolean" =
		'true'i
		{
			return true;
		}
	/	'false'i
		{
			return false;
		}

null "null" =
	'null'i
{
	return NULL_OBJECT;
}



string "string" =
		(
			'"'
			s:(
				(
					'\\'
					e:escseq
					{
						return e;
					}
				)
			/	[^\\"]
			)*
			'"'
		)
		{
			return flatten(s);
		}
	/	(
			"'"
			s:(
				(
					'\\'
					e:escseq
					{
						return e;
					}
				)
			/	[^\\']
			)*
			"'"
		)
		{
			return flatten(s);
		}

escseq =
		(
			k:[bfnrt]
			{
				switch (k) {
					case "b": return "\b";
					case "f": return "\f";
					case "n": return "\n";
					case "r": return "\r";
					default:  return "\t";
				}
			}
		)
	/	(
			'u' hd:(hexdigit hexdigit hexdigit hexdigit)
			{
				return String.fromCharCode(parseInt(flatten(hd), 16));
			}
		)
	/	(
			// Any other escaped char is passed as is
			j:.
			{
				return j;
			}
		)


number "number" =
n:(
	sign?
	(
		(
			'0' [xX] hexdigit+
		)
		/ (
			'0' digit+
		)
		/ (
			(
				(
					( '0' / (Digit digit*) )
					( '.' digit+ )?
				)
			/	( '.' digit+ )
			)
			exponent?
		)
	)
)
{
	var fn = flatten(n);

	if (/^[+-]?0[xX]/.test(fn)) {
		return parseInt(fn, 16);
	}

	if (/^[+-]?0[0-7]+$/.test(fn)) {
		return parseInt(fn, 8);
	}

	return parseFloat(fn);
}

sign = [+-]

exponent =
	[eE]
	sign?
	digit+

Digit = [1-9]

digit = [0-9]

hexdigit = [0-9a-fA-F]


WS "whitespace" = [ \t\n\r] / COMMENT

CWS "whitespace" = [ \t\n\r,] / COMMENT

COMMENT "comment" = LINE_COMMENT / MULTI_COMMENT

LINE_COMMENT "line comment" =
	'//'
	[^\n\r]*

MULTI_COMMENT "multi-line comment" =
	'/*'
	(
		[^*]
		/ ('*' &[^/])
	)*
	'*/'
